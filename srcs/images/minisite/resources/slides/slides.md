---
layout: cover
colorSchema: dark
background: https://cdn-www.konbini.com/fr/files/2020/01/inception.jpg
---

# Inception

by aguiot--

---

# What's those slides?

Those slides will present you my Inception project, explain how it is structured, how to run it, and give a little explanation of each service.

I made it with [Slidev](https://sli.dev), a cool tool to create slides with simple Markdown.  
You can check the source by opening `minisite/resources/slides/slides.md`

---

# Project structure

```bash
├── Makefile                            ├── minisite/                     ├── vsftpd/
├── README.md                           │   ├── Dockerfile                │   ├── Dockerfile
└── srcs/                               │   ├── README.md                 │   ├── docker-entrypoint.sh
    ├── docker-compose.yaml             │   ├── config.json               │   └── vsftpd.conf.tmpl
    └── images/                         │   ├── config.production.json    │
        ├── adminer/                    │   ├── go.mod                    └── wordpress/
        │   ├── Dockerfile              │   ├── go.sum                        ├── Dockerfile
        │   ├── docker-entrypoint.sh    │   ├── http                          ├── docker-entrypoint.sh
        │   └── www.conf                │   ├── main.go                       ├── wp-config.php
        │                               │   └── resources                     └── www.conf
        ├── goaccess/                   │
        │   ├── Dockerfile              ├── nginx/
        │   ├── docker-entrypoint.sh    │   ├── Dockerfile
        │   └── goaccess.conf           │   ├── default.conf.tmpl
        │                               │   ├── docker-entrypoint.sh
        ├── mariadb/                    │   └── nginx.conf
        │   ├── Dockerfile              │
        │   ├── docker-entrypoint.sh    ├── redis/
        │   ├── mariadb-server.cnf      │   ├── Dockerfile
        │   └── seed.sql.tmpl           │   └── redis.conf
        │                               │

```

---

# How to run it

Pretty simple! Just run `make`.

It will:
1. Build all images
2. Start all the containers
3. Show all the logs

---

# More make commands

Here are some useful commands. Yes my Makefile is 427 lines long.

* Start all and follow logs: `make run`
* Start all in background: `make upd`
* Show services and their status: `make ps`
* Down all: `make down` (`downv` for volumes)
* Clean all: `make clean` (`fclean` for volumes and their data)
* Full reset: `make re`
* Up one specific service: `make <service>.up` (`upd`for background)
* Down one specific service: `make <service>.down` (`downv`for volumes)
* Get logs of one specific service: `make <service>.logs` (`logsf` to follow)
* Start shell in one specific service: `make <service>.shell` (`shell.root` to be root)
* Start client of one specific service: `make <service>.client` (e.g redis-cli for redis)
* Build one specific service: `make <service>.build`

---

# NGINX

### Web Server and Reverse Proxy

It's the entrypoint of the stack. It accepts HTTP requests on port 443 (HTTPS), and forwards it to either php-fpm (wordpress, adminer) or the Go http server (minisite).  
It also serves the static HTML file generated by the go-access service.

It connectes to these services via the `nginx` network, and can read their data via the `wordpress-data`, `adminer-data` and `goaccess-data` volumes.  
In turn, the goaccess service reads the NGINX's logs via the `nginx-log` volume. Finally, the SSL certificate is accessed with the `ssl` volume.

The domain name (login.42.fr) can be configured with the `DOMAIN_NAME` environment variable.

The upstreams configuration is based on a template (`default.conf.tmpl`), and parsed by [Dockerize](https://github.com/jwilder/dockerize) at runtime.  
Check it inside the container, at `/etc/nginx/conf.d/default.conf`. (Use `make nginx.shell` to open a shell inside the container)

---

# WordPress + php-fpm

### CMS + PHP

This container holds the WordPress installation, and the associated php-fpm process, which will be reached by NGINX to execute WP's php files.

It uses the `nginx` network to do so, but also the `mariadb` and `redis` networks to connect to the database and the cache store.  
WordPress data is stored in the `wordpress-data` volume, which is also used by NGINX.

The WordPress installation can be configured with all the `WP_*` environment variables (see `docker-compose.yaml`), as well as the database connection with the `DB_*` variables.

The WP CLi is installed at buildtime, but the site installation is made at runtime (because it needs infos about this specific site installation).

---

# MariaDB

### Database

The database is used by WordPress to store all the site content. IF you create a post or a comment, it will be stored here.

It is accessed via the `mariadb` network and uses the `mariadb-data` volume to persist data.

The connection informations are stored in all the `DB_*` environment variables (see `docker-compose.yaml`).

The MariaDB server is installed and configured on build, and the database is initialized on the first run, using the `seed.sql.tmpl` [Dockerize](https://github.com/jwilder/dockerize) template.

---

# Redis

### Cache store

Redis is used as the cache store of WordPress. Its data is not persisted since it is only cache, holding user sessions and stuff like that.

It only uses the `redis` network to communicate with WordPress.

There is no environment variables for Redis, because it has no authentication (it's safe since it's not exposed).

The installation and configuration is made on build.

---

# vsftpd

### FTP server

vsftpd (Very Secure FTP Daemon) allows to run an FTP server and to access or edit WordPress files with an user-friendly GUI client (i.e FileZilla).

It exposes port `21` for initial FTP connection and ports `21000` to `21010` for Passive Mode connections.  
The `wordpress-data` volumes allows to read/edit WP files, and the `ssl` volume allows to use the SSL certificate to encrypt the connection.

The username/password and Passive Mode port range can be configured with the `FTP_*` environment variables (see `docker-compose.yaml`).

The file permissions and configuration are handled at runtime. [Dockerize](https://github.com/jwilder/dockerize) is used to parse the configuration template (`vsftpd.conf.tmpl`).

---

# Adminer

### Database web interface (+ php-fpm)

This one-php-file tool allows you to administrate your database via web browser. It is exposed by NGINX on `login.42.fr/adminer`, and use php-fpm similarly to the wordpress container.

It uses the `mariadb` and `nginx` networks to access the database and be reached by NGINX, which reads its data via the `adminer-data` volume.

No enviroment variable are used.

The installation and configuration is made at buildtime. It only consists of php-fpm's configuration file (`www.conf`) and a custom Adminer theme that I have chosen ([Hydra](https://github.com/Niyko/Hydra-Dark-Theme-for-Adminer)).

---

# Minisite

### Mini demo site + slides

A really simple static website using a Go backend and some slides written with [Slidev](https://sli.dev). Wait... Aren't we inside this right now? Is this Inception?  
I wanted two different tools to show off Docker Multi Stage Builds, which consists of using multiple stages in our Dockerfile to compile our applicatio**s**, and then create the final stage.  
Check it in `minisite/Dockerfile` if you are curious! (Actually you are kind of supposed to check it, if you are my evaluator)

It uses the `nginx` network to be `proxy_pass`'d and has no volume since it's a static site.

The only environment variable is `SLIDEV_BASE`, which allows to change the slides base path (i.e `/minisite/slides`).

The Go application is built on buildtime, as well as the slides (but in a different stage!), and then we just copy the static assets to the final stage.  
The runtime only starts the Go app and serves these static assets.

---

# Goaccess

### Web log analyzer

This final service allows you to inspect your HTTP logs, which can be really useful if you run a public site (such as a WordPress).  
It reads your logs and then create an HTML report file. This file in then served by NGINX on `login.42.fr/goaccess`.

No network is used, not even the `nginx` one, since the only requirement is the HTML report file, which is read via the `goaccess-data` volume.
To read NGINX's logs, goaccess uses the `nginx-log` volume.

There is no environment variable used.

The simple configuration is added at buildtime, and the runtime only starts goaccess.

